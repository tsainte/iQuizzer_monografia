\chapter{Fundamentação teórica e ferramentas} \label{CHP:FUND}

\section{Serviços PaaS}
\subsection{Definição}

	 Computação em nuvem refere-se a capacidade de processamento e armazenamento na internet. Neste paradigma, é necessário apenas um cliente, com componentes de entrada e saída de dados, para realizar o acesso aos recursos de um computador, através de serviços. Um dos serviços definidos é o \ac{PaaS}.

	De acordo com o \ac{NIST}, o \ac{PaaS} é ``a capacidade fornecida ao consumidor de publicar aplicações usando linguagem de programação, bibliotecas e serviços suportados pelo provedor''. Com o fornecimento de tal serviço, o consumidor não precisa se preocupar com o controle de certos serviços de infraestrutura, como a rede, servidores, sistemas operacionais, armazenamento, ou seja, cria-se uma camada de abstração de serviços de infraestrutura.
	
	Os serviços \ac{PaaS} possuem as seguintes características \cite{cloudstack}:
\begin{itemize}
\item Serviços para desenvolver, testar, publicar, hospedar e manter aplicações de forma integrada;
\item Arquitetura \emph{multitenancy}, onde uma única instância do \emph{software} executa em um servidor, servindo à multiplas organizações clientes (\emph{tentants}).
\item Construção garantindo escalabilidade, incluindo balanceamento de carga (\emph{load balancing}) e replicação de dados para recuperação de falhas (\emph{failover});
\item Integração com \emph{web services} e banco de dados através de padrões comuns;
\item Suporte para desenvolvimento em equipes, podendo ter ferramentas de planejamento de projetos e de comunicação;
\item Ferramentas para gerenciamento dos custos.
\end{itemize}

	Assim, sistemas \ac{PaaS} são úteis para desenvolvedores individuais e \emph{startups}\footnote{Termo utilizado para designar modelo de negócios repetível e escalável, em um ambiente de extrema incerteza. Normalmente, projetos ou empresas \emph{startups} estão associadas a áreas de tecnologia.}, pois fornecem facilidade de publicação sem os custos e complexidades de \emph{hardwares} e \emph{softwares} inerentes a uma aplicação \emph{web} comum \cite{guardianstartup}.
	
	Os principais provedores de serviços \ac{PaaS} são: Google App Engine, Windows Azure e Heroku.
	
\subsection{Heroku}

	O \emph{Heroku} é uma plataforma \emph{cloud} de serviços \ac{PaaS} montado sobre o \emph{Amazon EC2}, existente desde junho de 2007. Possui suporte para as seguintes linguagens: Ruby, Java, Node.JS, Scala, Clojure, Python e PHP. Ao contrário de seus concorrentes Google App Engine e Windows Azure, o Heroku fornece suporte a Ruby nativo\footnote{O Google App Engine fornece suporte ao JRuby, uma implementação Ruby sobre a máquina virtual do Java.}, tendo sido por isso escolhido para este projeto.
	
	Inicialmente, o \emph{Heroku} foi desenvolvido com suporte exclusivo para a linguagem Ruby. Em julho de 2011, Matz Matsumoto, criador do Ruby, entrou para a empresa como arquiteto-chefe e, nesse mesmo mês, passou a dar suporte também para Node.js e Clojure.
Em setembro de 2011, a rede social \emph{Facebook} fez uma parceria com o \emph{Heroku} a fim de facilitar a publicação de aplicativos para sua própria plataforma \cite{faceheroku}. Em poucos passos, é possível criar uma aplicação no \emph{Facebook} e no \emph{Heroku}, simultaneamente.

O \emph{Heroku} usa uma unidade de máquina virtual chamada ``Dyno'' com quatro núcleos e até $512MB$ de RAM, sobre o sistema operacional Ubuntu.

	

\section{REST}
 O \ac{REST} é uma arquitura de engenharia de \emph{software} para sistemas hipermídia distribuidos sobre a \emph{world wide web}. O termo foi definido em uma tese de doutorado por Roy Fielding\cite{fielding}.


	De modo geral, o \ac{REST} é uma interface de comunicação onde há um provedor de serviços e um consumidor. Tal interface pode ser descrita utilizando \ac{XML}, \ac{HTTP}, \ac{YAML}, \ac{JSON} ou até mesmo texto puro, de modo a não utilizar trocas de mensagens complexas como o \ac{SOAP}. 

O \ac{REST} possui alguns princípios, a saber:
\begin{itemize}
\item Modelo provedor/consumidor \emph{stateless} (sem estado): cada mensagem \ac{HTTP} trocada possui todas as informações necessárias para a comunicação, ou seja, nenhuma das partes necessita gravar estado da comunicação. Em sistemas \emph{web}, é comum o uso de \emph{cookies}\footnote{\emph{Cookie} é um grupo de dados trocado entre o navegador e o servidor, colocado num arquivo de texto criado no computador do cliente. Sua função principal é a de manter a persistência de sessões \ac{HTTP}.} para manter o estado da sessão entre requisições sucessivas. Já em sistemas \emph{mobile}, é comum a utilização de um \emph{token} de autenticação com a mesma finalidade.

\item Operações \ac{HTTP}: de modo a diminuir o tráfego de dados, são utilizados métodos \ac{HTTP}, definidos no RFC 2616\cite{rfc2616}, para acessar os recursos de informação. As operações mais utilizadas são o \texttt{GET}, \texttt{PUT}, \texttt{POST} e \texttt{DELETE}. Em sistemas \ac{REST}, é comum combinar tais métodos com operações de \ac{CRUD}, que faz persistência de dados em um determinado recurso ou entidade.

\item Identificação de recursos: as URLs identificam cada uma das entidades e seus elementos, ficando a cargo da operação \ac{HTTP} definir a ação a ser feita com cada um dos recursos ou elementos.

\item Uso de hipermídia: as trocas de mensagem de comunicação são feitas utilizando, no corpo da mensagem \ac{HTTP}, uma linguagem de marcação, conforme já citado anteriormente. Porém, não há uma restrição geral quanto ao uso, podendo ser usada linguagens próprias (texto puro).

\end{itemize}
\subsection{RESTful}

	Em uma arquitetura julgada como \emph{RESTful}, o método desejado é informado dentro do método \ac{HTTP}, contido no \emph{header} do mesmo. Além disso, o escopo da informação é colocado na própria \ac{URL}. Por definição, uma aplicação deixa de ser \emph{RESTFul} caso o método \ac{HTTP} não combine com o método da informação, ou seja, com a funcionalidade esperada para aquela estrutura de dados \cite{restfulws}. 

\section{JSON}
\subsection{Introdução}
\ac{JSON} é um padrão aberto de texto para representar estruturas de dados, de forma inteligível para humanos.  Sua origem é a linguagem JavaScript, e seu formato está descrito no RFC 4627\cite{rfc4627}.

\subsection{Definição}
	O \ac{JSON} é um dos formatos mais usados na serialização e transmissão de dados estruturados pela internet, ao lado do \ac{XML} e \ac{YAML}, sendo muito usado em sistemas orientados a serviço e/ou \emph{web services}. Muitas linguagens e \emph{frameworks}, como o ``Foundation'' (\emph{iOS}) e o ``\emph{Android}'', dão suporte para esse padrão, através de \emph{parsers}\footnote{Em português, \emph{parsers} são analisadores sintáticos que analisam uma sequência de entrada para determinar sua estrutura gramatical segundo uma determinada gramática formal.} para construção e consumo.
	
De acordo com \cite{restfulws}, ``é muito mais fácil para um \emph{browser} lidar com uma estrutura JavaScript oriunda de uma estrutura \ac{JSON} do que a partir de um documento \ac{XML}''. Ainda de acordo com a fonte, cada navegador oferece uma interface JavaScript diferente para seus \emph{parsers} \ac{XML}, enquanto um objeto \ac{JSON}, que por definição é um objeto JavaScript, será interpretado da mesma maneira em qualquer interpretador JavaScript. O \ac{JSON} é uma alternativa mais leve para serialização de dados do que o \ac{XML}, definido pelo ``XML Schema''. 

\subsection{comparação com XML}
	\ac{JSON} e \ac{XML} são dois formatos de manipulação de informações que podem ser usados com o mesmo objetivo, mas possuem implementações e aplicações distintas. 

	No artigo \emph{Comparison of json and xml data interchange formats: A case study}\cite{comparexmljson}, é feito um estudo considerando a hipótese de que não há diferença em relação ao tempo de transmissão e os recursos utilizados entre \ac{JSON} e \ac{XML}. A fim de realizar o estudo, foi criado um ambiente operacional consistindo de uma aplicação cliente/servidor em Java, onde o servidor escuta uma porta e o cliente se conecta. 

	No referido teste, foram utilizadas as seguintes métricas: número de objetos enviados, tempo total para enviar o número de objetos, tempo médio de transmissão, uso da CPU pelo usuário, uso da CPU pelo sistema e o uso de memória.

	De acordo com a conclusão do artigo, codificação \ac{JSON} é, em geral, mais rápida e consome menos recursos que a codificação \ac{XML}, o que nega a hipótese de igualdade de escolha entre as duas tecnologias. Ou seja, em um ambiente onde é necessário um  tempo de resposta rápido e os recursos são limitados, como sistemas móveis, é preferível utilizar \ac{JSON}.

\subsection{Estrutura}
	De acordo com W3resource \cite{w3json}, o \ac{JSON} suporta duas grandes estruturas de informação: coleção de pares chave/valor e listas ordenadas de valores. Ambas estruturas são também suportadas pela maioria das linguagens de programação modernas, o que reforça a ideia de ser uma boa escolha de linguagem para transmissão de informações.
	
	O \ac{JSON} possui alguns tipos de dados, a saber:
\begin{itemize}
\item Objetos: um objeto começa e termina com ``\{'' e ``\}'', contendo um número de pares chave/valor.  A separação entre uma chave e um valor é feita com o caractere ``:'',  e a separação entre pares é feita com ``,''. O valor de um par pode ser qualquer estrutura \ac{JSON}.
\item Arrays: Um array começa e termina com ``['' e ``]''. Entre eles, são adicionados certo número de valores, separados por ``,''. 
\item Valores: os valores podem ser string, número, objeto, array, valor booleano ou nulo.
\end{itemize}
Exemplo de código \ac{JSON}:

\begin{lstlisting}
{
    "firstName": "Bidhan",
    "lastName": "Chatterjee",
    "age": 40,
    "address": {
        "streetAddress": "144 J B Hazra Road",
        "city": "Burdwan",
        "state": "Paschimbanga",
        "postalCode": "713102"
    },
    "phoneNumber": [
        {
            "type": "personal",
            "number": "09832209761"
        },
        {
            "type": "fax",
            "number": "91-342-2567692"
        }
    ]
}
\end{lstlisting}

\section{Ruby on Rails}

\subsection{Ruby}
	Ruby é uma linguagem de programação orientada a objetos, com tipagem forte e dinâmica, criada por Yukihiro Matsumoto (Matz) e lançada em 1995\cite{rubyhistory}. 
	
	Segundo a Caelum\cite{caelum}, uma de suas principais características é sua expressividade, ou seja, a facilidade de ser lida e entendida, o que facilitaria o desenvolvimento de sistemas escritos por ela.
	
	O livro \emph{Learning Rails 3} \cite{rails3} lista algumas das características mais importantes do Ruby, a saber:
\begin{itemize}
\item É uma linguagem interpretada. Em consequência, um sistema em Ruby pode se tornar um pouco mais lento, porém, é notável o ganho em flexibilidade;
\item Possui uma sintaxe de linguagem flexível, fazendo com que a curva de aprendizado seja menor em relação a outras linguagens. Um exemplo clássico é a não-necessidade (opcional) de escrever parênteses ao redor dos parâmetros de um método. Entretanto, podem surgir erros de difícil depuração por não colocar parênteses em algumas situações ambíguas;
\item Possui uma tipagem dinâmica, ou seja, não é necessário especificar o tipo de informação que será guardado em cada variável. Isso torna a abordagem bem mais flexível, tornando as operações dependentes do próprio contexto. Entretanto, isso também permite a ocorrência de comportamentos inesperados e de difícil depuração;
\item Suporte a blocos e \emph{closures}\footnote{Em uma \emph{closure}, uma função é declarada dentro do corpo de outra, e a função interior pode referenciar variáveis locais da função exterior.}.
\end{itemize}
	
	Atualmente, Ruby encontra-se entre as linguagens de programação mais populares, ocupando a posição 11º no índice Tiobe\footnote{O índice TIOBE mede, mensalmente, a popularidade de uma determinada linguagem de programação, baseado no número de engenheiros qualificados, cursos, vendedores e buscas nos principais motores de busca. Pode ser encontrado em \url{http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html} }, liderados pelas linguagens C e Java.   Grande parte desse sucesso deve-se ao \emph{framework} \emph{Rails}, implementado como solução \emph{web} utilizando Ruby.

\subsection{Rails}
	O \emph{Ruby on Rails}, também chamado \emph{Rails} ou \emph{RoR}, é um \emph{framework} de desenvolvimento \emph{web} de código aberto que tem como premissa aumentar a velocidade e a facilidade no desenvolvimento de aplicações \emph{web} orientados a banco de dados.  Foi lançado oficialmente em julho de 2004 pelo seu criador David H. Hansson, estando atualmente na versão $3.2.11$, com a 4ª versão em desenvolvimento \cite{rails4}.  
	
	O \emph{Rails} é um \emph{framework} \emph{full-stack}, ou em português, arcabouço de desenvolvimento. Isso significa que, com ele, é possível desenvolver a aplicação por completo, desde os \emph{layouts} das páginas, à manutenção do banco de dados. Além disso, o \emph{Rails} enfatiza o uso de alguns padrões de engenharia de \emph{software}, a saber:
	
\begin{itemize}
\item \emph{Active record}: padrão de projeto para armazenamento de dados em banco de dados relacionais.  A interface de um certo objeto deve incluir funções de \ac{CRUD},  como inserir, atualizar, apagar e algumas funções de consulta. Cada tabela de um banco de dados é ``envelopada''  em um uma classe, sendo cada instância dessa classe um registro (tupla) único na tabela.  Esse conceito foi  definido por Martin Fowler em \cite{fowler}.
\item Convenção sobre configuração: modelo de desenvolvimento de \emph{software} que busca diminuir o número de decisões que os desenvolvedores precisam tomar, ou seja, o desenvolvedor não precisa definir aspectos convencionais da aplicação. Em \emph{Rails}, é fácil perceber esse padrão na escolha dos nomes das tabelas: se um modelo chama-se ``Usuario'', a tabela correspondente se chamará ``Usuarios'' e, se existir uma relação entre usuários e contas (m:m), a nova tabela será denominada, automaticamente, $usuarios\_contas$.
\item \ac{DRY}: O objetivo principal é reduzir a repetição de informação de qualquer tipo. Esse conceito incentiva o bom uso da reutilização de código, que é também uma das principais vantagens da orientação a objetos.
\item \ac{MVC}: esse padrão de arquitetura de \emph{software} separa a aplicação em três camadas: uma contendo a lógica da aplicação e regra de negócios, chamada \emph{model}; uma contendo a entrada e saída de dados com o usuário, chamada \emph{view}; uma interligando ambas, de maneira a manipular dados da \emph{view} para o \emph{model} entender e vice-versa, chamada \emph{controller}. O principal objetivo dessa arquitetura é a reusabilidade de código e a separação de conceitos \cite{mvc}.
\end{itemize}


 	De acordo com a apostila da Caelum \cite{caelum}, a estrutura sobre a qual o \emph{Rails} é feito permite que as funcionalidades de um sistema possam ser implementadas de maneira incremental, por conta dos padrões e conceitos supracitados. Por conseqüência, isso tornaria o Rails uma boa escolha para projetos e empresas que adotam metodologias ágeis no desenvolvimento da aplicação.

 	O Ruby é uma linguagem interpretada. Antes de se tornar popular, existia apenas um interpretador disponível, escrito em C pelo próprio criador da linguagem. Hoje em dia, o interpretador mais conhecido é o 1.9 ou \ac{YARV}, para a versão mais atualizada e estável (Ruby $1.9.3$.).
 	
	Existem outros interpretadores Ruby famosos, como:
 \begin{itemize}
 \item JRuby: implementação alternativa que permite usar a \ac{JVM} do Java para interpetar código Ruby. Uma de suas principais vantagens é a interoperabilidade com código Java existente, além de aproveitar as vantagens já maduras do java: \emph{garbage collector}\footnote{\emph{garbage collector} é um processo usado para a automação do gerenciamento de memória}, \emph{threads} nativas, etc.
 \item IronRuby: Implementação .Net da linguagem, mantido pela própria Microsoft.
 \item Rubinius: Traz idéias de máquinas virtuais do SmallTalk e é implementada em C/C++.
 \end{itemize}
 \section{Smartphones}

 	O mercado de \emph{smartphones} tem crescido vertiginosamente nos últimos anos. Estima-se que no ínicio de 2012 o número de celulares inteligentes tenha atingido a marca de 1 bilhão de unidades vendidas e, segundo projeções, esse número deve dobrar em 2015 \cite{yahoosmart}. 
 	
	Embora o número de \emph{smartphones} seja expressivo, ele ainda é pequeno se comparado ao número de pessoas que possuem um aparelho celular. Isso significa que ainda há muito espaço para crescimento, em particular em mercados emergentes como a China, Índia e Brasil.
 	
	Usualmente, um \emph{smartphone} possui alguns recursos de ponta, como câmera, bom reprodutor de mídia, bom processamento gráfico para jogos, bluetooth, GPS, acesso a internet via wi-fi e 3G/4G, \ac{NFC}, um bom sistema operacional, entre outros. 
 Atualmente, os sistemas operacionais mais populares para \emph{smartphones} são: \emph{Android}, \emph{iOS} (Apple), \emph{Blackberry OS} (RIM), Bada (Samsung), \emph{Symbian} e \emph{Windows Phone 7} (Microsoft). A distribuição do mercado, no Q3\footnote{Q3 faz referência ao trimestre entre julho e setembro. As denominações Q1, Q2, Q3 e Q4, para os trimestres do ano, são comuns em relatórios financeiros.} de 2012, pode ser vista no seguinte gráfico:
 \begin{figure}[H]
   % Requires \usepackage{graphicx}
   \centering
   \includegraphics[width=0.8\linewidth]{figs/smartpizza.png}\\
   \caption{ \emph{Marketshare} Q3 2012}
   \label{FIG:smartpizza}
 \end{figure}
 Fonte: NewWin \cite{neowin}
 
 Notadamente, o \emph{Android} e o \emph{iOS} são as plataformas mais populares. O grande diferencial entre o \emph{marketshare}\footnote{Termo que designa a fatia de mercado que o objeto de estudo possui em relação a seus concorrentes.} desses dois sistemas é o segmento de mercado: enquanto o \emph{Android} atua em todos os segmentos, desde celulares \emph{low-end} aos celulares de ponta, o \emph{iOS} atua somente com celulares de ponta, chamados \emph{high-end}. Outro fato a considerar é que, nesse gráfico, não são contemplados outros dispositivos, como reprodutores de música e \emph{tablets}.

 \section{iOS}
 \subsection{Visão Geral}

 O \emph{iOS} é um sistema operacional para dispositivos móveis, lançado pela Apple em 2007. Inicialmente, foi desenvolvido para o iPhone, sendo posteriormente aproveitado nos dispositivos iPod Touch, iPad e Apple TV. Ele é um sistema operacional licenciado para funcionar apenas em \emph{hardware} produzido pela Apple, otimizado para a arquitetura de processadores ARM.
 
 Sua entrada de dados é feita de forma direta, através de multi-toques. Esses toques podem ser desde o toque, similar a um clique do mouse, até balançar o aparelho, de modo a utilizar seu acelerômetro. Todos os controles de entrada de dados são controlados pela \ac{GUI} ``Cocoa Touch''.
 
 O livro ``Use a cabeça - iPhone'' \cite{usecabecaiphone} cita que o iPhone revolucionou a maneira de ver um celular: ele é, atualmente, uma plataforma de jogos, um organizador pessoal, um \emph{browser}(navegador) completo e um telefone. Muito de seu sucesso deve-se ao êxito da loja virtual ``App Store'', de mídias e aplicativos, que abriu oportunidade para desenvolvedores independentes competirem em escala mundial com grandes empresas de \emph{software}. 

 \subsection{Objective-c}
 A programação nativa em \emph{iOS} utiliza uma linguagem de programação chamada Objective-C. 
 
 O Objective-C é uma linguagem de programação reflexiva e orientada a objeto, com origens no SmallTalk e no C. Foi criada no início da década de 80 por Brad Cox e Tom Love, mas somente se tornou popular quando foi licenciada pela NeXT, de Steve Jobs, em 1988. Atualmente é a principal linguagem utilizada para desenvolvimento para Mac OS X.
 
 Como o Objective-C foi construido sobre C, qualquer código C pode ser compilado com um compilador Objective-C. Por definição, é uma camada sobre o C que aceita orientação a objetos, através de mensagens.
 
 Em linguagens com \emph{message parsing}, métodos não são chamados por objetos, mas sim mensagens são enviadas ao objeto. Essa diferença implica em como o código referenciado pelo método ou nome da mensagem é executado. Neste caso, o ``alvo'' da mensagem é resolvido em tempo de execução, com o objeto receptor interpretando a mensagem.

 \subsection{Ciclo de vida}
 O ciclo de vida constitui uma sequência de eventos entre o início e a finalização da aplicação. Um aplicativo \emph{iOS} começa quando o usuário toca o ícone do mesmo na tela inicial do dispositivo. Feito isso, o sistema operacional inicia alguns procedimentos de renderização e chama a função principal (main.m) do aplicativo.
 
 Uma vez iniciado, o comando da execução passa a ser do UIKit, \emph{framework} de controle do \emph{iOS}, que carrega a interface gráfica e lê o ciclo (\emph{loop}) de eventos. Durante o \emph{loop}, o UIKit delega cada evento a seu respectivo objeto e responde aos comandos emitidos pelo aplicativo. Quando o usuário realiza uma ação que causa um evento de saída, o UIKit notifica a aplicação e inicia o processo de saída.


 \section{Android}

 \subsection{Visão Geral}
 	O \emph{Android} é a proposta da Google para ocupar o segmento de mercado de sistemas operacionais para plataformas móveis. Consiste em um sistema baseado no sistema operacional Linux, com diversas aplicações já instaladas, além de um ambiente de desenvolvimento forte e flexível. 
	
 	De acordo com o \emph{Google Android}, de Ricardo Lecheta \cite{lecheta}, o \emph{Android} causou um grande impacto quando foi anunciado, em especial, pelas empresas que estavam por trás de seu desenvolvimento: Google, Motorola, LG, Samsung, Sony, entre muitas outras. A esse grupo de empresas, denominado \ac{OHA}, coube a padronização de uma plataforma de código aberto e livre para celulares, com o objetivo de atender a uma demanda de mercado.
	
 	Um dos pontos fortes do \emph{Android} é seu sistema flexível: é fácil integrar aplicações nativas com a sua aplicação, ou até mesmo substituir algumas dessas aplicações nativas pela sua própria. Isso gera um grande apelo para empresas de telefonia, que podem usar dessa personalização para lançarem suas próprias versões de aparelhos \emph{Android} personalizados.
	
 	O grande foco do \emph{Android} é a interação entre aplicativos: agenda, mapas, contatos são facilmente alcançáveis por qualquer aplicação. Essa funcionalidade é realizada por um recurso chamado \emph{intent}.%, que será abordado em capítulos posteriores.
	
 	Outro ponto forte do \emph{Android} é que seu sistema operacional é baseado no Linux (baseado no kernel 2.6), ou seja, ele mesmo se encarrega de gerenciar a memória em uso e os processos. Isso faz com que seja possível rodar mais de uma aplicação (genuinamente) ao mesmo tempo, fazendo com que outros aplicativos rodem em segundo plano durante outros serviços, como ao atender um telefonema ou acessar a internet.  
	
 	O que é dito como vantagem também é apontado, fatalmente, como um problema: uma vez que aplicativos podem rodar em segundo plano, aplicativos maliciosos também podem ser rodados em segundo plano. Durante muito tempo, aplicativos desse tipo podiam ser encontrados para download no Google Play, havendo hoje uma melhor seleção dos aplicativos que de fato estão sendo disponibilizados na loja.

 \subsection{Java} 
 	A linguagem nativa de programação para \emph{Android} é o Java, utilizando o \emph{framework} \emph{Android} criado pela \ac{OHA}.
 	
	O Java é uma linguagem de propósito geral, concorrente e orientada a objetos. Sua primeira versão foi lançada em 1995 pela Sun Microsystems e, atualmente, encontra-se em sua sétima versão, sendo mantida pela Oracle. 
	
 	Atualmente, é uma das linguagens de programação mais populares do mundo, ocupando o 2º lugar no índice TIOBE. Devido a isso, há um grande número de desenvolvedores que possuem o pré-requisito básico para iniciar programação para \emph{Android}: o domínio da linguagem.
	
 	O grande sucesso do Java é normalmente creditado a sua capacidade de funcionar nos mais diversos ambientes, desde micro-sistemas como cartões de crédito a grandes plataformas \emph{web}. Isso é devido à implementação de sua máquina virtual, que é capaz de rodar nas mais diversas plataformas. 


 \subsection{Ciclo de vida}
 	 O ciclo de vida de uma aplicação \emph{Android} é controlado por uma \emph{Activity}, a qual também gerencia a interface com o usuário, recebe requisições, realiza o tratamento e processa.
	 
 	Toda \emph{Activity} possui os seguintes métodos de controle, a saber:
 \begin{itemize}
 \item onCreate(): é o primeiro método a ser executado em uma \emph{Activity}. Usualmente é o método responsável por carregar os layouts XML e inicializar atributos de classe e outros serviços.
 \item onStart(): é chamado imediatamente chamado após o onCreate(). Diferentemente deste, é chamado toda vez que a \emph{Activity} volta a ter foco após um período em \emph{background}.
 \item onResume(): Assim como o onStart(), é chamado no início da \emph{Activity} e, também, quando a mesma volta a ter foco. A diferença entre ambos é que o onStart() só é invocado quando a \emph{Activity} não está mais visível, enquanto o onResume() é chamado toda vez que retorna o foco.
 \item onPause(): é a primeira função a ser chamada quando a \emph{Activity} perde o foco.
 \item onStop(): é chamado quando uma \emph{Activity} é substituída por outra \emph{Activity}
 \item onDestroy(): é o último método a ser executado. Quando o onDestroy() é executado, a \emph{Activity} é considerada ``morta'' e fica pronta para ser removida pelo \emph{Garbage Collector}.
 \item	onRestart(): Chamado quando a \emph{Activity} sai do estado de ``stop''; após sua execução, é chamado o método onStart().
 \end{itemize}

 %\section{Redes Sociais}  será que vale mesmo a pena falar sobre isso?
 \section{Resumo do Capítulo}

 	Neste capítulo foram abordadas os três principais paradigmas necessários para o desenvolvimento deste projeto: computação em nuvem, \emph{web services} e computação móvel. Tais paradigmas foram aprofundaoas em um nível o qual fornecessem ao leitor os pré-requisitos para a compreensão do restante do projeto, o qual será apresentado nos capítulos posteriores.
 
